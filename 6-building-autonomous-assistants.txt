This chapter covers
Behavior trees for robotics and AI apps
GPT Assistants Playground and creating assistants and actions
Autonomous control of agentic behavior trees
Simulating conversational multi-agent systems via agentic behavior trees
Using back chaining to create behavior trees for complex systems
Now that we’ve covered how actions extend the power/capabilities of agents, we can look at how behavior trees can guide agentic systems. We’ll start by understanding the basics of behavior trees and how they control robotics and AI in games.

We’ll return to agentic actions and examine how actions can be implemented on the OpenAI Assistants platform using the GPT Assistants Playground project. From there, we’ll look at how to build an autonomous agentic behavior tree (ABT) using OpenAI assistants. Then, we’ll move on to understanding the need for controls and guardrails on autonomous agents and using control barrier functions.

In the final section of the chapter, we’ll examine the use of the AgentOps platform to monitor our autonomous behavior-driven agentic systems. This will be an exciting chapter with several challenges. Let’s begin by jumping into the next section, which introduces behavior trees.

6.1 Introducing behavior trees
Livebook feature - Free preview
In livebook, text is enibgsyat in books you do not own, but our free preview unlocks it for a couple of minutes.
Tvaehoir rtese tvz s unfk-debatislehs arpetnt kcqy kr rolncto rotibcso chn YJ nj gsame. Yydeon B. Trskoo itfsr ucrnediodt rkq pctecno nj cuj “Y Yuostb Ederaey Alotrno Stsmey ktl z Wloeib Bkrgk” arppe jn 1986. Rcgj cfpj rgv onwgkrduor txl c atretpn rrgc pneexdad xn sniug ord tvro qns enku urrectuts vw vocu atody.

Jl heg’xx oxtk eplyda c rtmpecou myzo grwj nreonaylp ertachcars (ULAa) xt nettidarce qwrj anddevac ictboro tsseysm, gvg’xe tweedissn evriohba terse zr kwte. Peugri 6.1 hossw s mesipl ehbaoirv rtov. Cvb orvt nerstpeser ffz prv mryirap deson: orcltees tx afbkclal neods, qncseuee eodns, aoncit denso, qzn nnotcdioi noeds.

Figure 6.1 A simple behavior tree of eating an apple or a pear
figure
Xfkzq 6.1 rciebsesd rdv ftusconin nbc uppsoer lk rbk iayrmrp dsnoe xw’ff lerxpoe nj cyjr xxyv. Aktkb tsv rheot oensd unz yxon eptsy, ncb ggx can nkkk eaetrc tucmso ndeso, rqp elt nkw, vw’ff scuof ne tsohe jn rpo elbta.

Table 6.1 The primary nodes used in behavior trees
Node
Purpose
Function
Type
Selector (fallback)
This node works by selecting the first child that completes successfully. It’s often called the fallback node because it will always fall back to the last successful node that executed.
The node calls its children in sequence and stops executing when the first child succeeds. When a child node succeeds, it will return success; if no nodes succeed, it returns failure.
Composite
Sequence
This node executes all of its children in sequence until one node fails or they all complete successfully.
The node calls each of its children in sequence regardless of whether they fail or succeed. If all children succeed, it returns success, and failure if just one child fails.
Composite
Condition
Behavior trees don’t use Boolean logic but rather success or failure as a means of control. The condition returns success if the condition is true and false otherwise.
The node returns success or failure based on a condition.
Task
Action
This is where the action happens.
The node executes and returns success if successful or returns failure otherwise.
Task
Decorator
They work by controlling the execution of child nodes. They are often referred to as conditionals because they can determine whether a node is worth executing or safe to execute.
The node controls execution of the child nodes. Decorators can operate as control barrier functions to block or prevent unwanted behaviors.
Decorator
Parallel
This node executes all of its nodes in parallel. Success or failure is controlled by a threshold of the number of children needed to succeed to return success.
The node executes all of its child nodes in sequence regardless of the status of the nodes.
Composite
Rog aprryim dsone jn btale 6.1 zcn vderpio ohegnu cnlyuiianttfo re lhnead snoeumru ocb sscae. Hreowev, edsndtnaginur bveaoirh rsete yiinltila ssn oh ndugitna. Bey wkn’r epctaearpi theri ernlydginu imoxteclyp iulnt dhx tatsr sngiu myor. Yfroee wv bidlu coxm ismpel tsree, ow wncr rx kfvx cr oetcunixe jn mktv teldai jn ruv onrv csnotie.

6.1.1 Understanding behavior tree execution
Diansdrntgnde dkw bhoviaer sreet ucxetee jz cralcui vr deiggsinn bns lmnmetgepnii vaiobreh eesrt. Oilenk rxmz cpnectso jn ctuemrpo cecsein, eaorivhb retes peteaor nj stmer lk scceuss nhs raelifu. Mnkp s ynxv nj s boreahiv xtrx ueecsetx, rj jffw rtunre terieh sscceus tx ireaful; ajgr kone ilsepap rv iditnnsoco znp eorlcest ednos.

Chaoriev esret uecetex tklm rkd rk ttoomb qnc rvlf rv right. Leriug 6.2 wohss orq spseroc cqn sryw nappseh lj c knxq alifs tv uedsscec. Jn dkr xmpeela, rop BJ rxu rtok nsoroctl spa cn aelpp rhh en hctk. Jn uor rfsti eesnquce eknu, z tininoodc eckhcs lj yrv CJ zuz nz lpaep. Ceuseca xpr YJ dsneo’r exuc zn lepap, jr btasor vrd eneqesuc sny lfsla zuvz re vyr tecolsre. Adv cersetol rvqn ectlsse arj kkrn ldich bxon, haonetr ceeqesnu, rzrd ccskeh lj rdo YJ sba c txqs, pzn cbeueas rj vqvc, vrd XJ svar vur ppeal.

Figure 6.2 The execution process of a simple behavior tree
figure
Xveohira trees oiepdvr oocrtln xvto xwd sn BJ sysemt fjfw etuecxe rz c oramc et iorcm ellve. Ygdeigarn icbsootr, oievhrab eestr wfjf aiylytlcp kp dsigdnee vr eetoarp rz rxb mroci evlle, erweh zosb ctaoni te octnindio ja s amsll vetne, zbab sz diecgntet xqr leapp. Benrleoysv, ebhvioar serte ssn fsax onrctlo mtov romac ssmtsye, bgsz sa GZAc nj smaeg, rwhee ysoc ocnita msb go z iabotnoncim kl esevnt, xjfe gcaittnak rpo areypl.

Vvt negacti etysssm, ihovaebr tesre poptsur lctoolginnr nc tgane te nistatsas cr xgbt csnohe lvlee. Mv’ff leorpxe cillnotonrg netasg sr rxd arco qsn, jn ltare rthaespc, orb nnalnpig lveesl. Yrltx sff, rwjp rdk owrep lv FEWa, tgnsae ssn oruccttns herti nwx oebahivr krxt.

Gl reosuc, evesalr oreht srfom lv RJ ctoonlr codul ku ckyd kr lnotroc gceitan tmsysse. Rdv novr cotnies fwjf aenmixe steho dtnfeierf esmysst zgn maocepr muor rv behairvo rtese.

6.1.2 Deciding on behavior trees
Umrseuou erhot XJ orcotnl styemss svbe ifntbsee hzn zvt htwro nrieolxpg jn nnrtciogllo neticag tmsysse. Xduv nss ndstetomare ruo ebietsnf vl hivoareb ertes gns redvopi eroht osinpto tle cifcipse cvh csaes. Bvq bhvoriea xrto zj ns exlntlece rnttepa, bpr jr jnc’r rgv vhnf kon, ngz jr’a worht laniregn batuo rsetho.

Yfuxs 6.2 tlhgigshhi eslrvae herto tsmysse wk spm irncsdeo etl nnootrillgc CJ smssyte. Vpss mrjx nj vgr ebtla edsberisc srwy qrv odemth kcpv, jra mgroscntoshi, gnz rjz psesboli alaitnppcoi vr iaegtcn TJ rooclnt.

Table 6.2 Comparison of other AI control systems
Control name
Description
Shortcomings
Control agentic AI?
Finite state machine a (FSM)
FSMs model AI using a set of states and transitions triggered by events or conditions.
FSMs can become unwieldy with increasing complexity.
FSMs aren’t practical for agents because they don’t scale well.
Decision tree b
Decision trees use a tree-like model of decisions and their possible consequences.
Decision trees can suffer from overfitting and lack generalization in complex scenarios.
Decision trees can be adapted and enhanced with behavior trees.
Utility-based system b
Utility functions evaluate and select the best action based on the current situation.
These systems require careful design of utility functions to balance priorities.
This pattern can be adopted within a behavior tree.
Rule-based system a
This set of if-then rules define the behavior of the AI.
These systems can become cumbersome with many rules, leading to potential conflicts.
These aren’t very practical when paired with agentic systems powered by LLMs.
Planning system c
Planning systems generate a sequence of actions to achieve a specific goal using planning algorithms.
These systems are computationally expensive and require significant domain knowledge.
Agents can already implement such patterns on their own as we’ll see in later chapters.
Behavioral cloning c
Behavioral cloning refers to learning policies by mimicking expert demonstrations.
This system may struggle with generalization to unseen situations.
This can be incorporated into behavior trees or into a specific task.
Hierarchical Task Network (HTN) d
HTNs decompose tasks into smaller, manageable subtasks arranged in a hierarchy.
These are complex to manage and design for very large tasks.
HTNs allow for better organization and execution of complex tasks. This pattern can be used for larger agentic systems.
Blackboard system b
These systems feature collaborative problem-solving using a shared blackboard for different subsystems.
These systems are difficult to implement and manage communication between subsystems.
Agentic systems can implement similar patterns using conversation or group chats/threads.
Genetic algorithm (GA) d
These optimization techniques are inspired by natural selection to evolve solutions to solve problems.
GAs are computationally intensive and may not always find the optimal solution.
GAs have potential and could even be used to optimize behavior trees.
a Not practical when considering complex agentic systems
b Exists in behavior trees or can easily be incorporated
c Typically applied at the task or action/condition level
d Advanced systems that would require heavy lifting when applied to agents
In later chapters of this book, we’ll investigate some of the patterns discussed in table 6.2. Overall, several patterns can be enhanced or incorporated using behavior trees as the base. While other patterns, such as FSMs, may be helpful for small experiments, they lack the scalability of behavior trees.

Behavior trees can provide several benefits as an AI control system, including scalability. The following list highlights other notable benefits of using behavior trees:

Modularity and reusability—Behavior trees promote a modular approach to designing behaviors, allowing developers to create reusable components. Nodes in a behavior tree can be easily reused across different parts of the tree or even in different projects, enhancing maintainability and reducing development time.
Scalability—As systems grow in complexity, behavior trees handle the addition of new behaviors more gracefully than other methods, such as FSMs. Behavior trees allow for the hierarchical organization of tasks, making it easier to manage and understand large behavior sets.
Flexibility and extensibility—Behavior trees offer a flexible framework where new nodes (actions, conditions, decorators) can be added without drastically altering the existing structure. This extensibility makes it straightforward to introduce new behaviors or modify existing ones to adapt to new requirements.
Debugging and visualization—Behavior trees provide a clear and intuitive visual representation of behaviors, which is beneficial for debugging and understanding the decision-making process. Tools that support behavior trees often include graphical editors that allow developers to visualize and debug the tree structure, making it easier to identify and fix problems.
Decoupling of decision logic—Behavior trees separate the decision-making and execution logic, promoting a clear distinction between high-level strategy and low-level actions. This decoupling simplifies the design and allows for more straightforward modifications and testing of specific behavior parts without affecting the entire system.
Having made a strong case for behavior trees, we should now consider how to implement them in code. In the next section, we look at how to build a simple behavior tree, using Python code.

6.1.3 Running behavior trees with Python and py_trees
Because behavior trees have been around for so long and have been incorporated into many technologies, creating a sample demonstration is very simple. Of course, the easiest way is to ask ChatGPT or your favorite AI chat tool. Listing 6.1 shows the result of using a prompt to generate the code sample and submitting figure 6.1 as the example tree. The final code had to be corrected for simple naming and parameter errors.

Note  All the code for this chapter can be found by downloading the GPT Assistants Playground project at https://mng.bz/Ea0q.

```
import py_trees

class HasApple(py_trees.behaviour.Behaviour):
    def __init__(self, name):
        super(HasApple, self).__init__(name)

    def update(self):
        if True:
            return py_trees.common.Status.SUCCESS
        else:
            return py_trees.common.Status.FAILURE
# Other classes omitted…

has_apple = HasApple(name="Has apple")
eat_apple = EatApple(name="Eat apple")
sequence_1 = py_trees.composites.Sequence(name="Sequence 1", memory=True)
sequence_1.add_children([has_apple, eat_apple])

has_pear = HasPear(name="Has pear")
eat_pear = EatPear(name="Eat pear")
sequence_2 = py_trees.composites.Sequence(name="Sequence 2", memory=True)
sequence_2.add_children([has_pear, eat_pear])

root = py_trees.composites.Selector(name="Selector", memory=True)
root.add_children([sequence_1, sequence_2])

behavior_tree = py_trees.trees.BehaviourTree(root)

py_trees.logging.level = py_trees.logging.Level.DEBUG
for i in range(1, 4):
    print("\n------------------ Tick {0} ------------------".format(i))
    behavior_tree.tick()

### Start of output
------------------ Tick 1 ------------------
[DEBUG] Selector             : Selector.tick()
[DEBUG] Selector             : Selector.tick() [!RUNNING->reset current_child]
[DEBUG] Sequence 1           : Sequence.tick()
[DEBUG] Has apple            : HasApple.tick()
[DEBUG] Has apple            : HasApple.stop(Status.INVALID->Status.SUCCESS)
[DEBUG] Eat apple            : EatApple.tick()
Eating apple
[DEBUG] Eat apple            : EatApple.stop(Status.INVALID->Status.SUCCESS)
[DEBUG] Sequence 1           : Sequence.stop()[Status.INVALID->Status.SUCCESS]
```

The code in listing 6.1 represents the behavior tree in figure 6.1. You can run this code as is or alter what the conditions return and then run the tree again. You can also change the behavior tree by removing one of the sequence nodes from the root selector.

Now that we have a basic understanding of behavior trees, we can move on to working with agents/assistants. Before doing that, we’ll look at a tool to help us work with OpenAI Assistants. This tool will help us wrap our first ABTs around OpenAI Assistants.


6.2 Exploring the GPT Assistants Playground
For the development of this book, several GitHub projects were created to address various aspects of building agents and assistants. One such project, the GPT Assistants Playground, is built using Gradio for the interface that mimics the OpenAI Assistants Playground but with several extras added.

The Playground project was developed as both a teaching and demonstration aid. Inside the project, the Python code uses the OpenAI Assistants API to create a chat interface and an agentic system to build and power assistants. There is also a comprehensive collection of actions assistants you can use, and you can easily add your own actions.

6.2.1 Installing and running the Playground
The following listing shows installing and running the Playground project from the terminal. There is currently no PyPI package to install.

Listing 6.2 Installing the GPT Assistants Playground
```
# change to a working folder and create a new Python virtual environment
git clone
 https://github.com/cxbxmxcx/GPTAssistantsPlayground
cd GPTAssistantsPlayground
pip install -r requirements.txt
```

You can run the application from the terminal or using Visual Studio Code (VS Code), with the latter giving you more control. Before running the application, you need to set your OpenAI API key through the command line or by creating an .env file, as we’ve done a few times already. Listing 6.3 shows an example of setting the environment variable on Linux/Mac or the Git Bash shell (Windows recommended) and running the application.

Listing 6.3 Running the GPT Assistants Playground
```
export OPENAI_API_KEY="your-api-key"
python main.py
```

Open your browser to the URL displayed (typically http://127.0.0.1:7860) or what is mentioned in the terminal. You’ll see an interface similar to that shown in figure 6.3. If you’ve already defined the OpenAI Assistants, you’ll see them in the Select Assistant dropdown.

Figure 6.3 The GPT Assistants Playground interface being used to learn math
If you’ve never defined an assistant, you can create one and choose the various options and instructions you need. If you’ve visited the OpenAI Playground, you’ve already experienced a similar interface.

GPT vs. an assistant
OpenAI defines a GPT as the assistant you can run and use within the ChatGPT interface. An assistant can only be consumed through the API and requires custom code in most cases. When you run an assistant, you’re charged according to the model token usage and any special tools, including the Code Interpreter and files, whereas a GPT runs within ChatGPT and is covered by account costs.

The reason for creating a local version of the Playground was an exercise to demonstrate the code structure but also provide additional features listed here:

Actions (custom actions)—Creating your own actions allows you to add any functionality you want to an assistant. As we’ll see, the Playground makes it very easy to create your own actions quickly.
Code runner—The API does come with a Code Interpreter, but it’s relatively expensive ($.03 per run), doesn’t allow you to install your modules, can’t run code interactively, and runs slowly. The Playground will enable you to run Python code locally in an isolated virtual environment. While not as secure as pushing code out to Docker images, it does execute code windowed and out of process better than other platforms.
Transparency and logging—The Playground provides for comprehensive capturing of logs and will even show how the assistant uses internal and external tools/actions. This can be an excellent way to see what the assistant is doing behind the scenes.
Each of these features is covered in more detail over the next few sections. We’ll start with a look at using and consuming actions in the next section.

6.2.2 Using and building custom actions
Actions and tools are the building blocks that empower agents and assistants. Without access to tools, agents are functionless chatbots. The OpenAI platform is a leader in establishing many of the patterns for tools, as we saw in chapter 3.

The Playground provides several custom actions that can be attached to assistants through the interface. In this next exercise, we’ll build a simple assistant and attach a couple of custom actions to see what is possible.

Figure 6.4 shows the expanded Actions accordion, which displays many available custom actions. Run the Playground from the terminal or debugger, and create a new assistant. Then, select the actions shown in the figure. After you’re done selecting the actions, scroll to the bottom, and click Add Assistant to add the assistant. Assistants need to be created before they can be used.

Figure 6.4 Selecting and using custom actions in the interface

After you create the assistant, you can ask it to list all available assistants. Listing the assistants also gives you the IDs required to call the assistant. You can also call other assistants and ask them to complete tasks in their area of specialization.

Adding your custom actions is as simple as adding code to a file and dropping it in the right folder. Open the playground/assistant_actions folder from the main project folder, and you’ll see several files that define the various actions. Open the file_actions.py file in VS Code, as shown in listing 6.4.

Listing 6.4 playground/assistant_actions/file_actions.py
After you create the assistant, you can ask it to list all available assistants. Listing the assistants also gives you the IDs required to call the assistant. You can also call other assistants and ask them to complete tasks in their area of specialization.

Adding your custom actions is as simple as adding code to a file and dropping it in the right folder. Open the playground/assistant_actions folder from the main project folder, and you’ll see several files that define the various actions. Open the file_actions.py file in VS Code, as shown in listing 6.4.

Listing 6.4 playground/assistant_actions/file_actions.py
```
import os

from playground.actions_manager import agent_action

OUTPUT_FOLDER = "assistant_outputs"


@agent_action
def save_file(filename, content):
    """
    Save content to a file.

    :param filename: The name of the file including extension.
    :param content: The content to save in the file.
    """
    file_path = os.path.join(OUTPUT_FOLDER, filename)
    with open(file_path, "w", encoding="utf-8") as file:
        file.write(content)
    print(f"File '{filename}' saved successfully.")
```

You can add any custom action you want by placing the file in the assistant_actions folder and decorating it with the agent_action decorator. Just make sure to give the function a good name and enter quality documentation for how the function should be used. When the Playground starts up, it loads all the actions in the folder that are decorated correctly and have descriptions/documentation.

It’s that simple. You can add several custom actions as needed. In the next section, we’ll look at a special custom action that allows the assistant to run code locally.

6.2.3 Installing the assistants database
To run several of the examples in this chapter, you’ll need to install the assistants database. Fortunately, this can be easily done through the interface and just by asking agents. The upcoming instructions detail the process for installing the assistants and are taken directly from the GPT Assistants Playground README. You can install several of the demo assistants located in the assistants.db SQLite database:

Create a new assistant, or use an existing assistant.
Give the assistant the create_manager_assistant action (found under the Actions section).
Ask the assistant to create the manager assistant (i.e., “please create the manager assistant”), and be sure to name the assistant “Manager Assistant.”
Refresh your browser to reload the assistants selector.
Select the new Manager Assistant. This assistant has the instructions and actions that will allow it to install assistants from the assistants.db database.
Talk to the Manager Assistant to give you a list of assistants to install, or just ask the Manager Assistant to install all available assistants.
6.2.4 Getting an assistant to run code locally
Getting agents and assistants to generate and run executable code has a lot of power. Unlike the Code Interpreter, running code locally provides numerous opportunities to iterate and tune quickly. We saw this earlier with AutoGen, where the agents could keep running the code until it worked as expected.

In the Playground, it’s a simple matter to select the custom action run_code, as shown in figure 6.5. You’ll also want to choose the run_shell_command action because it allows the assistant to pip install any required modules.

You can now ask an assistant to generate and run the code to be sure it works on your behalf. Try this out by adding the custom actions and asking the assistant to generate and run code, as shown in figure 6.6. If the code doesn’t work as expected, tell the assistant what problems you encountered.

You can add any custom action you want by placing the file in the assistant_actions folder and decorating it with the agent_action decorator. Just make sure to give the function a good name and enter quality documentation for how the function should be used. When the Playground starts up, it loads all the actions in the folder that are decorated correctly and have descriptions/documentation.

It’s that simple. You can add several custom actions as needed. In the next section, we’ll look at a special custom action that allows the assistant to run code locally.

6.2.3 Installing the assistants database
To run several of the examples in this chapter, you’ll need to install the assistants database. Fortunately, this can be easily done through the interface and just by asking agents. The upcoming instructions detail the process for installing the assistants and are taken directly from the GPT Assistants Playground README. You can install several of the demo assistants located in the assistants.db SQLite database:

Create a new assistant, or use an existing assistant.
Give the assistant the create_manager_assistant action (found under the Actions section).
Ask the assistant to create the manager assistant (i.e., “please create the manager assistant”), and be sure to name the assistant “Manager Assistant.”
Refresh your browser to reload the assistants selector.
Select the new Manager Assistant. This assistant has the instructions and actions that will allow it to install assistants from the assistants.db database.
Talk to the Manager Assistant to give you a list of assistants to install, or just ask the Manager Assistant to install all available assistants.

6.2.4 Getting an assistant to run code locally
Getting agents and assistants to generate and run executable code has a lot of power. Unlike the Code Interpreter, running code locally provides numerous opportunities to iterate and tune quickly. We saw this earlier with AutoGen, where the agents could keep running the code until it worked as expected.

In the Playground, it’s a simple matter to select the custom action run_code, as shown in figure 6.5. You’ll also want to choose the run_shell_command action because it allows the assistant to pip install any required modules.

You can now ask an assistant to generate and run the code to be sure it works on your behalf. Try this out by adding the custom actions and asking the assistant to generate and run code, as shown in figure 6.6. If the code doesn’t work as expected, tell the assistant what problems you encountered.

Again, the Python code running in the Playground creates a new virtual environment in a project subfolder. This system works well if you’re not running any operating system–level code or low-level code. If you need something more robust, a good option is AutoGen, which uses Docker containers to run isolated code.

Adding actions to run code or other tasks can make assistants feel like a black box. Fortunately, the OpenAI Assistants API allows you to consume events and see what the assistant is doing behind the scenes. In the next section, we’ll see what this looks like.

6.2.5 Investigating the assistant process through logs
OpenAI added a feature into the Assistants API that allows you to listen to events and actions chained through tool/action use. This feature has been integrated into the Playground, capturing action and tool use when an assistant calls another assistant.

We can try this by asking an assistant to use a tool and then open the log. A great example of how you can do this is by giving an assistant the Code Interpreter tool and then asking it to plot an equation. Figure 6.7 shows an example of this exercise.

Usually, when the Assistant Code Interpreter tool is enabled, you don’t see any code generation or execution. This feature allows you to see all tools and actions used by the assistant as they happen. Not only is it an excellent tool for diagnostics, but it also provides additional insights into the functions of LLMs.

We haven’t reviewed the code to do all this because it’s extensive and will likely undergo several changes. That being said, if you plan on working with the Assistants API, this project is a good place to start. With the Playground introduced, we can continue our journey into ABTs in the next section.

6.3 Introducing agentic behavior trees
Agentic behavior trees (ABTs) implement behavior trees on assistant and agent systems. The key difference between regular behavior trees and ABTs is that they use prompts to direct actions and conditions. Because prompts may return a high occurrence of random results, we could also name these trees stochastic behavior trees, which do exist. For simplicity, we’ll differentiate behavior trees used to control agents, referring to them as agentic.

Next, we’ll undertake an exercise to create an ABT. The finished tree will be written in Python but will require the setup and configuration of various assistants. We’ll cover how to manage assistants using the assistants themselves.

6.3.1 Managing assistants with assistants
Fortunately, the Playground can help us quickly manage and create the assistants. We’ll first install the Manager Assistant, followed by installing the predefined assistants. let’s get started with installing the Manager Assistant using the following steps:

Open Playground in your browser, and create a new simple assistant or use an existing assistant. If you need a new assistant, create it and then select it.
With the assistant selected, open the Actions accordion, and select the create_ manager_assistant action. You don’t need to save; the interface will update the assistant automatically.
Now, in the chat interface, prompt the assistant with the following: “Please create the manager assistant.”
After a few seconds, the assistant will say it’s done. Refresh your browser, and confirm that the Manager Assistant is now available. If, for some reason, the new assistant isn’t shown, try restarting the Gradio app itself.
The Manager Assistant is like an admin that has access to everything. When engaging the Manager Assistant, be sure to be specific about your requests. With the Manager Assistant active, you can now install new assistants used in the book using the following steps:

Select the Manager Assistant. If you’ve modified the Manager Assistant, you can delete it and reinstall it anytime. Although it’s possible to have multiple Manager Assistants, it’s not recommended.
Ask the Manager Assistant what assistants can be installed by typing the following in the chat interface:

```
Please list all the installable assistants.
```

Identify which assistant you want installed when you ask the Manager Assistant to install it:

```
Please install the Python Coding Assistant.
```

You can manage and install any available assistants using the Playground. You can also ask the Manager Assistant to save the definitions of all your assistants as JSON:

```
Please save all the assistants as JSON to a file called assistants.json.
```

The Manager Assistant can access all actions, which should be considered unique and used sparingly. When crafting assistants, it’s best to keep them goal specific and limit the actions to just what they need. This not only avoids giving the AI too many decisions but also avoids accidents or mistakes caused by hallucinations.

As we go through the remaining exercises in this chapter, you’ll likely need to install the required assistants. Alternatively, you can ask the Manager Assistant to install all available assistants. Either way, we look at creating an ABT with assistants in the next section.

6.3.2 Building a coding challenge ABT
Coding challenges provide a good baseline for testing and evaluating agent and assistant systems. Challenges and benchmarks can quantify how well an agent or agentic system operates. We already applied coding challenges to multi-platform agents in chapter 4 with AutoGen and CrewAI.

For this coding challenge, we’re going a little further and looking at Python coding challenges from the Edabit site (https://edabit.com), which range in complexity from beginner to expert. We’ll stick with the expert code challenges because GPT-4o and other models are excellent coders. Look at the challenge in the next listing, and think about how you would solve it.

```
Plant the Grass by AniXDownLoe

    You will be given a matrix representing a field g
and two numbers x, y coordinate.

    There are three types of possible characters in the matrix:

        x representing a rock.
        o representing a dirt space.
        + representing a grassed space.

    You have to simulate grass growing from the position (x, y).
    Grass can grow in all four directions (up, left, right, down).
    Grass can only grow on dirt spaces and can't go past rocks.

    Return the simulated matrix.
    Examples

    simulate_grass([
    "xxxxxxx",
    "xooooox",
    "xxxxoox"
    "xoooxxx"
    "xxxxxxx"
    ], 1, 1) → [
    "xxxxxxx",
    "x+++++x",
    "xxxx++x"
    "xoooxxx"
    "xxxxxxx"
    ]

    Notes

    There will always be rocks on the perimeter
```


You can use any challenge or coding exercise you want, but here are a few things to consider:

The challenge should be testable with quantifiable assertions (pass/fail).
Avoid opening windows when asking for a game, building a website, or using another interface. At some point, testing full interfaces will be possible, but for now, it’s just text output.
Avoid long-running challenges, at least initially. Start by keeping the challenges concise and short lived.
Along with any challenge, you’ll also want a set of tests or assertions to confirm the solution works. On Edabit, a challenge typically provides a comprehensive set of tests. The following listing shows the additional tests provided with the challenge.


```
Test.assert_equals(simulate_grass(
["xxxxxxx","xooooox","xxxxoox","xoooxxx","xxxxxxx"],
 1, 1),
["xxxxxxx","x+++++x","xxxx++x","xoooxxx","xxxxxxx"])
    Test.assert_equals(simulate_grass(
["xxxxxxx","xoxooox","xxoooox","xooxxxx",
"xoxooox","xoxooox","xxxxxxx"],
 2, 3), ["xxxxxxx","xox+++x","xx++++x","x++xxxx",
"x+xooox","x+xooox","xxxxxxx"])
    Test.assert_equals(simulate_grass(
["xxxxxx","xoxoox","xxooox","xoooox","xoooox","xxxxxx"],
1, 1),
["xxxxxx","x+xoox","xxooox","xoooox","xoooox","xxxxxx"])
    Test.assert_equals(simulate_grass(
["xxxxx","xooox","xooox","xooox","xxxxx"],
1, 1),
["xxxxx","x+++x","x+++x","x+++x","xxxxx"])
    Test.assert_equals(simulate_grass(
["xxxxxx","xxxxox","xxooox","xoooxx","xooxxx",
"xooxxx","xxooox","xxxoxx","xxxxxx"],
4, 1),
["xxxxxx","xxxx+x","xx+++x","x+++xx","x++xxx",
"x++xxx","xx+++x","xxx+xx","xxxxxx"])
    Test.assert_equals(simulate_grass(
["xxxxxxxxxxx", "xoxooooooox", "xoxoxxxxxox",
"xoxoxoooxox", "xoxoxoxoxox", "xoxoxoxoxox",
"xoxoxxxoxox", "xoxoooooxox", "xoxxxxxxxox",
"xooooooooox", "xxxxxxxxxxx"], 1, 1),
["xxxxxxxxxxx", "x+x+++++++x", "x+x+xxxxx+x",
"x+x+x+++x+x", "x+x+x+x+x+x", "x+x+x+x+x+x",
"x+x+xxx+x+x", "x+x+++++x+x", "x+xxxxxxx+x",
"x+++++++++x", "xxxxxxxxxxx"])
```

The tests will be run as part of a two-step verification to confirm that the solution works. We’ll also use the tests and challenges as written, which will further test the AI.

Figure 6.8 shows the makeup of a straightforward behavior tree that will be used to solve various programming challenges. You’ll notice that this ABT uses a different assistant for the actions and conditions. For the first step, the Python coding assistant (called the Hacker) generates a solution that is then reviewed by the coding challenge Judge (called the Judge), which produces a refined solution that is verified by a different Python coding assistant (called the Verifier).

Figure 6.8 also shows how each agent converses on which thread. Assistants use message threads, similar to a Slack or Discord channel, where all assistants conversing on a thread will see all messages. For this ABT, we keep one main conversation thread for the Hacker and Judge to share messages, while the Verifier works on a separate message thread. Keeping the Verifier on its own thread isolates it from the noise of the solution-solving efforts.

Now, building the ABT in code is a matter of combining the py_trees package and the Playground API functions. Listing 6.7 shows an excerpt of code that creates each of the action/condition nodes with the assistants and gives them the instructions.

```
root = py_trees.composites.Sequence("RootSequence", memory=True)


thread = api.create_thread()
challenge = textwrap.dedent("""

""")
judge_test_cases = textwrap.dedent("""

""")

hacker = create_assistant_action_on_thread(
    thread=thread,
    action_name="Hacker",
    assistant_name="Python Coding Assistant",
    assistant_instructions=textwrap.dedent(f"""
    Challenge goal:
    {challenge}
    Solve the challenge and output the
final solution to a file called solution.py
    """),
)
root.add_child(hacker)

judge = create_assistant_action_on_thread(
    thread=thread,
    action_name="Judge solution",
    assistant_name="Coding Challenge Judge",
    assistant_instructions=textwrap.dedent(
        f"""
    Challenge goal:
    {challenge}
    Load the solution from the file solution.py.
    Then confirm is a solution to the challenge
and test it with the following test cases:
    {judge_test_cases}
    Run the code for the solution and confirm it passes all the test cases.
    If the solution passes all tests save the solution to a file called
judged_solution.py
    """,
    ),
)
root.add_child(judge)

# verifier operates on a different thread, essentially in closed room
verifier = create_assistant_condition(
    condition_name="Verify solution",
    assistant_name="Python Coding Assistant",
    assistant_instructions=textwrap.dedent(
        f"""
    Challenge goal:
    {challenge}
    Load the file called judged_solution.py and
verify that the solution is correct by running the code and confirm it passes
all the test cases:
    {judge_test_cases}
    If the solution is correct, return only the single word SUCCESS, otherwise
return the single word FAILURE.
    """,
    ),
)
root.add_child(verifier)

tree = py_trees.trees.BehaviourTree(root)


while True:
    tree.tick()
    time.sleep(20)
    if root.status == py_trees.common.Status.SUCCESS:
        break
### Required assistants –
### Python Coding Assistant and Coding Challenge Judge
### install these assistants through the Playground
```

















































